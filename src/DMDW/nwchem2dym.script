#!/bin/sh

# Convert the output from an NWCHEM freq run to a dym file for use with dmdw

# This is the output file from the calculation, should be the result of
# redirecting standard out to a file
out_file=$1

# This is the [name].hess file generated by NWCHEM
hess_file=$2

# [NOTE: Will leave this till next update]
# First we do some sanity checks to make sure that the files we have are
# minimally correct
#gawk "/Northwest Computational Chemistry Package/" $out_file

gawk '
#  Reminder of n/m
function mod(n,m){
  return n - m*int(n/m);
}
# Minimum of x and y
function min(x,y){
  if ( x < y )
    return x
  else
    return y
  endif
}
# Distance between points v1 and v2
function dist(v1,v2){
  return sqrt( (v2[1]-v1[1])^2 + (v2[2]-v1[2])^2 + (v2[3]-v1[3])^2 );
}
function size(Data){
  j = 0;
  for ( i in Data )
    j++;
  return j;
}
function sort(Data,Ind){
# Get the size of the array
  n = size(Data);
# Initialize the swapped indices array
  for(i=1;i<=n;i++)
    Ind[i] = i;
  for(i=1;i<=n-1;i++)
    for(j=i+1;j<=n;j++)
      if ( Data[Ind[j]] < Data[Ind[i]] )
        {
         t      = Ind[j];
         Ind[j] = Ind[i];
         Ind[i] = t;
        }
}
# Print out a symmetric array in column form
function Prn_SMat(Size,A){
  nCol = 5;
  nl = int(Size/nCol);
  nr = mod(Size,nCol);

  for(k=1;k<=nl;k++)
    {
     printf "     ";
     for(j=(k-1)*nCol+1;j<=k*nCol;j++)
       printf "%7d       ", j;
     printf " \n";
     for(i=(k-1)*nCol+1;i<=Size;i++)
       {
        printf "%3d", i;
        for(j=(k-1)*nCol+1;j<=min(k*nCol,i);j++)
          printf " %13.6e", A[i,j];
        printf " \n";
       }
    }

  if (nr != 0) then
    {
     printf "     ";
     for(j=nl*nCol+1;j<=Size;j++)
       printf "%7d       ", j;
     printf " \n";
     for(i=nl*nCol+1;i<=Size;i++)
       {
        printf "%3d", i;
        for(j=nl*nCol+1;j<=min(Size,i);j++)
          printf " %13.6e", A[i,j];
        printf " \n";
       }
    }
}
# Print out an arbitrary array in column form
function Prn_Mat(Size,A){
  nCol = 5;
  nl = int(Size/nCol);
  nr = mod(Size,nCol);

  for(k=1;k<=nl;k++)
    {
     printf "     ";
     for(j=(k-1)*nCol+1;j<=k*nCol;j++)
       printf "%7d       ", j;
     printf " \n";
     for(i=1;i<=Size;i++)
       {
        printf "%3d", i;
        for(j=(k-1)*nCol+1;j<=k*nCol;j++)
          printf " %13.6e", A[i,j];
        printf " \n";
       }
     printf " \n";
    }

  if (nr != 0) then
    {
     printf "     ";
     for(j=nl*nCol+1;j<=Size;j++)
       printf "%7d       ", j;
     printf " \n";
     for(i=1;i<=Size;i++)
       {
        printf "%3d", i;
        for(j=nl*nCol+1;j<=Size;j++)
          printf " %13.6e", A[i,j];
        printf " \n";
       }
     printf " \n";
    }
}
BEGIN{
# Define conversion between AU and Ang
  au2ang = 0.52917706;
# Define conversion from atomi units of force to N/m
# auf2npm = 1556.89279161;
# Define the force scaling factor
# FSca = (0.9806)^2;
  FSca = 1.0;
  NATOMS_FLAG = 1;
  AN_FLAG     = 1;
  FREQ_FLAG   = 0;
}
# Find the number of atoms
/No. of atoms     :/&&NATOMS_FLAG{
  nAtoms = $5;
  NATOMS_FLAG = 0;
# Debug
# printf "%3d\n", nAtoms;
}
# Get the atomic numbers
/No.       Tag          Charge/&&!NATOMS_FLAG&&AN_FLAG{
  getline;
  getline;
  for(iAtom=1;iAtom<=nAtoms;iAtom++)
    {
     AN[iAtom] = $3;
     getline;
    }
  AN_FLAG = 0;
# Debug
# for(iAtom=1;iAtom<=nAtoms;iAtom++)
#   printf "%3d\n", AN[iAtom];
}
# Make sure we are in the frequency section
/Vibrational analysis via the FX method/{
  FREQ_FLAG = 1;
}
# Read the cartesian coordinates and atomic masses of the system
/- Atom information -/{
  getline;
  getline;
  getline;
  for(iAt=1;iAt<=nAtoms;iAt++)
    {
     XYZ[iAt,1] = $3; XYZ[iAt,2] = $4; XYZ[iAt,3] = $5;
     sub("D","e",XYZ[iAt,1]); sub("D","e",XYZ[iAt,2]); sub("D","e",XYZ[iAt,3]);
     AW[iAt] = $6;
     sub("D","e",AW[iAt]);
     getline;
    }
# Debug
# for(iAtom=1;iAtom<=nAtoms;iAtom++)
#   {
#    for(p=1;p<=3;p++)
#      printf " %15.8e", XYZ[iAtom,p];
#    printf "\n";
#   }
}
# Print the extracted information
END{
# Calculate the number of coordinates
  nCoord = 3*nAtoms

# Print the kind of information in this "dym" file:
# This will likely change in the future.. :-)
# 0: old incomplete format
# 1: new complete format, no fancy cell info
# 2: new complete format WITH cell info (for self energy calculations)
# 3: experimental format including Gaussians dipole derivatives
  printf " %3d\n", 1;

# Print the number of atoms
  printf " %3d\n", nAtoms;

# Print the atomic number of the atoms
  for(iAtom=1;iAtom<=nAtoms;iAtom++)
    printf " %3d\n", AN[iAtom];

# Print the atomic weights of the atoms
  for(iAtom=1;iAtom<=nAtoms;iAtom++)
    printf " %14.8f\n", AW[iAtom];

# Print out the coordinates
  for(iAtom=1;iAtom<=nAtoms;iAtom++)
    {
     for(p=1;p<=3;p++)
       printf " %12.8f", XYZ[iAtom,p];
     printf "\n";
    }

}
' $out_file

# Now we process the .hess file
# [NOTE: we should add some sanity checks here, but will leave this for later]

gawk '
BEGIN{
# Define conversion from atomi units of force to N/m
# auf2npm = 1556.89279161;
# Define the force scaling factor
# FSca = (0.9806)^2;
  FSca = 1.0;
}
# Read the cartesian force constants of the system
{   
  BufferFC[NR] = $1;
  gsub("D","e",BufferFC[NR]);
  nFC = NR;
}
# Print the extracted information
END{
# Calculate the number of coordinates
  nCoord = (sqrt(8*nFC+1)-1)/2;
  nAtoms = nCoord/3;

# Transform the cartesian force constants vector buffer into a symmetric array
  iE = 0;
  for(j=1;j<=nCoord;j++)
    {
     for(i=1;i<=j;i++)
       {
        iE++;
        FC[i,j] = BufferFC[iE];
        FC[j,i] = FC[i,j];
       }
    }

# Print the blocked dynamical matrix for each pair of atoms
  for(iAtom=1;iAtom<=nAtoms;iAtom++)
    for(jAtom=1;jAtom<=nAtoms;jAtom++)
      {

# Print the atoms
       printf " %3d %3d\n", iAtom, jAtom;

# Print the dynamical matrix block
       for(p=1;p<=3;p++)
         {
          for(q=1;q<=3;q++)
            printf " %13.6e", FSca*FC[3*(iAtom-1)+p,3*(jAtom-1)+q];
          printf "\n";
         }
      }

}
' $hess_file
